---
import Layout from "@/layouts/Layout.astro";
import Breadcrumb from "@/components/post/Breadcrumb.astro";
import PostHeader from "@/components/post/PostHeader.astro";
import PostFooter from "@/components/post/PostFooter.astro";
import PostNav from "@/components/post/PostNav.astro";
import AiSimilarPosts from "@/components/post/AiSimilarPosts.astro";
import AiSummaryCard from "@/components/post/AiSummaryCard.astro";
import WalineComments from "@/components/post/WalineComments.svelte";
import { getCollection, render } from "astro:content";
import themeConfig from "@/theme.config";
import type {
  TocItem,
  QuickNavigation,
} from "@/components/sidebar/SidebarTypes";

import "@/styles/post.css";

import "katex/dist/katex-swap.min.css";
import { avatar } from "@/components/Images.astro";

import "@/styles/spoiler.css";

export async function getStaticPaths() {
  const posts = await getCollection("posts");
  const sortedPosts = posts
    .filter((post) => !post.data.draft)
    .sort((a, b) => b.data.date.getTime() - a.data.date.getTime());

  return sortedPosts.map((post, index) => {
    const prevPost = index > 0 ? sortedPosts[index - 1] : undefined;
    const nextPost =
      index < sortedPosts.length - 1 ? sortedPosts[index + 1] : undefined;

    // Get related posts from the same category
    const categories = post.data.categories || [];
    const relatedPosts =
      categories.length > 0
        ? sortedPosts
            .filter(
              (p) =>
                p.id !== post.id &&
                p.data.categories?.some((c) => categories.includes(c)),
            )
            .slice(0, 10)
            .map((p) => ({
              slug: p.id,
              title: p.data.title,
              date: p.data.date,
              category: p.data.categories?.[0],
            }))
        : [];

    return {
      params: { slug: post.id },
      props: {
        post,
        prevPost: prevPost
          ? {
              title: prevPost.data.title,
              slug: prevPost.id,
              category: prevPost.data.categories?.[0],
              cover: prevPost.data.cover,
            }
          : undefined,
        nextPost: nextPost
          ? {
              title: nextPost.data.title,
              slug: nextPost.id,
              category: nextPost.data.categories?.[0],
              cover: nextPost.data.cover,
            }
          : undefined,
        relatedPosts,
      },
    };
  });
}

const { post, prevPost, nextPost, relatedPosts } = Astro.props as {
  post: import("astro:content").CollectionEntry<"posts">;
  prevPost?: {
    title: string;
    slug: string;
    category?: string;
    cover?: string;
  };
  nextPost?: {
    title: string;
    slug: string;
    category?: string;
    cover?: string;
  };
  relatedPosts: {
    slug: string;
    title: string;
    date: Date;
    category?: string;
  }[];
};

const { Content, headings } = await render(post);

// Build TOC from headings
const toc: TocItem[] = headings.map((h) => ({
  id: h.slug,
  text: h.text,
  level: h.depth,
}));

// Build quick navigation
const navigation: QuickNavigation = {
  prevUrl: prevPost ? `/posts/${prevPost.slug}/` : undefined,
  prevTitle: prevPost?.title,
  nextUrl: nextPost ? `/posts/${nextPost.slug}/` : undefined,
  nextTitle: nextPost?.title,
};

// Calculate word count from content
const plainText = (post.body || "")
  .replace(/[#*`_[\]()]/g, "")
  .replace(/\s+/g, " ");
const wordCount = plainText.length;

// Calculate read time (assume 300 words per minute)
const readTime = Math.ceil(wordCount / 300);

// Get site info from config
const siteConfig = themeConfig.sidebar || {};
const author = siteConfig.author || "Author";
const siteName = themeConfig.siteName || "Site";
const commentsConfig = themeConfig.comments || {};
const walineConfig = commentsConfig.waline || {};

const hycConfig = themeConfig.hyc || {};
const aiRecommendConfig = hycConfig.aiRecommend || {};
const aiSummaryConfig = hycConfig.aiSummary || {};
const hycEnable = hycConfig.enable === true;
const aiRecommendEnable = aiRecommendConfig.enable !== false;
const aiSummaryEnable = aiSummaryConfig.enable !== false;
const aiSummaryTitle = aiSummaryConfig.title || "AI 摘要";
const aiSummaryShowModel = aiSummaryConfig.showModel === true;
const aiRecommendLimit = Math.max(
  1,
  Math.min(10, aiRecommendConfig.limit ?? 3),
);
const aiRecommendMinSimilarityRaw = aiRecommendConfig.minSimilarity ?? 0.4;
const aiRecommendMinSimilarity = Math.min(
  1,
  Math.max(
    0,
    aiRecommendMinSimilarityRaw > 1
      ? aiRecommendMinSimilarityRaw / 100
      : aiRecommendMinSimilarityRaw,
  ),
);

interface AiRecommendPost {
  slug: string;
  title: string;
  score: number;
}

interface PostAiSummary {
  content: string | null;
  model: string | null;
}

let aiRecommendPosts: AiRecommendPost[] = [];
let aiSummary: PostAiSummary | null = null;

if (hycEnable && aiSummaryEnable) {
  try {
    const { getPostSummary } = await import("@hyacine/cli/api");

    if (typeof getPostSummary !== "function") {
      throw new Error(
        "getPostSummary is not available in current @hyacine/cli",
      );
    }

    const summaryResult = (await getPostSummary(post.id)) as {
      summary?: {
        content?: string | null;
        model?: string | null;
      };
    } | null;

    if (summaryResult?.summary?.content) {
      aiSummary = {
        content: summaryResult.summary.content,
        model: summaryResult.summary.model ?? null,
      };
    }
  } catch {
    aiSummary = null;
  }
}

if (hycEnable && aiRecommendEnable) {
  try {
    const { findSimilarPosts } = await import("@hyacine/cli/api");
    const similarResult = await findSimilarPosts({
      query: post.id,
      limit: aiRecommendLimit,
    });

    aiRecommendPosts = (similarResult.items || [])
      .filter((item) => item.slug && item.slug !== post.id)
      .filter(
        (item) =>
          typeof item.score === "number" &&
          item.score >= aiRecommendMinSimilarity,
      )
      .sort((a, b) => b.score - a.score)
      .slice(0, aiRecommendLimit)
      .map((item) => ({
        slug: item.slug,
        title: item.title,
        score: item.score,
      }));
  } catch {
    aiRecommendPosts = [];
  }
}

// Current post path (trailing slash required by project routing)
const postPath = `/posts/${post.id}/`;

// Build permalink
const permalink = Astro.site
  ? new URL(postPath, Astro.site).toString()
  : postPath;

// Build postMeta for Brand component
const postMeta = {
  date: post.data.date,
  wordCount,
  readTime,
};
---

<Layout
  toc={toc}
  relatedPosts={relatedPosts}
  currentSlug={post.id}
  navigation={navigation}
  pageTitle={post.data.title}
  postMeta={postMeta}
>
  <Fragment slot="head">
    <meta
      name="description"
      content={post.data.description ||
        post.body?.slice(0, 150).replace(/\s+/g, " ")}
    />
  </Fragment>

  <Fragment>
    <div class="article wrap">
      <Breadcrumb categories={post.data.categories ?? undefined} />

      <article
        itemscope
        itemtype="http://schema.org/Article"
        class="post block"
        data-pagefind-body
        lang="zh-CN"
      >
        <link itemprop="mainEntityOfPage" href={permalink} />

        <span
          hidden
          itemprop="author"
          itemscope
          itemtype="http://schema.org/Person"
        >
          <meta itemprop="image" content={avatar.src} />
          <meta itemprop="name" content={author} />
          <meta itemprop="description" content={`${siteName}`} />
        </span>

        <span
          hidden
          itemprop="publisher"
          itemscope
          itemtype="http://schema.org/Organization"
        >
          <meta itemprop="name" content={siteName} />
        </span>

        <PostHeader
          title={post.data.title}
          link={post.data.link}
          date={post.data.date}
          updated={post.data.updated}
          wordCount={wordCount}
        />

        <AiSummaryCard
          summary={aiSummary?.content}
          model={aiSummary?.model}
          title={aiSummaryTitle}
          showModel={aiSummaryShowModel}
        />

        <div class="body md" itemprop="articleBody" data-pagefind-body>
          <Content />

          {
            post.data.tags && post.data.tags.length > 0 && (
              <div class="tags">
                {post.data.tags.map((tag) => (
                  <a
                    href={`/tags/${tag.toLowerCase().replace(/\s+/g, "-")}/`}
                    rel="tag"
                  >
                    <i class="icon i-ri-price-tag-3-line" />
                    {tag}
                  </a>
                ))}
              </div>
            )
          }
        </div>

        <AiSimilarPosts
          posts={aiRecommendPosts}
          minSimilarity={aiRecommendMinSimilarity}
        />

        <PostFooter
          date={post.data.date}
          updated={post.data.updated}
          permalink={permalink}
          title={post.data.title}
          author={author}
          siteName={siteName}
          showCopyright={true}
          showReward={false}
          license={post.data.license}
        />
      </article>
    </div>

    <PostNav
      prevPost={prevPost}
      nextPost={nextPost}
      nextGradientCover={themeConfig.cover?.nextGradientCover}
    />

    {
      commentsConfig.enable !== false && (
        <div id="comments" class="comment">
          <WalineComments
            client:visible
            serverURL={walineConfig.serverURL}
            lang={walineConfig.lang || themeConfig.locale || "zh-CN"}
            dark={walineConfig.dark}
            path={walineConfig.path}
            pagePath={postPath}
          />
        </div>
      )
    }
  </Fragment>
</Layout>
